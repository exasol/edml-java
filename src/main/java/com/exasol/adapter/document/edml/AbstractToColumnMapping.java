
package com.exasol.adapter.document.edml;

/**
 * Abstract base for EDML mappings that map to an Exasol column.
 */

public abstract class AbstractToColumnMapping implements MappingDefinition {
    private final String destinationName;
    private final String description;
    private final KeyType key;
    private final boolean required;

    /**
     * Builder class. The content of the builder is generated by lombok. We need this class declared here since the
     * Javadoc generation fails otherwise.
     *
     * @param <C> type used by lombok
     * @param <B> type used by lombok
     */
    public abstract static class AbstractToColumnMappingBuilder<C extends AbstractToColumnMapping, B extends AbstractToColumnMappingBuilder<C, B>> {

        private String destinationName;

        private String description;

        private boolean key$set;

        private KeyType key$value;

        private boolean required$set;

        private boolean required$value;

        protected abstract B self();

        public abstract C build();

        /**
         * @return {@code this}.
         */

        public B destinationName(final String destinationName) {
            this.destinationName = destinationName;
            return self();
        }

        /**
         * @return {@code this}.
         */

        public B description(final String description) {
            this.description = description;
            return self();
        }

        /**
         * @return {@code this}.
         */

        public B key(final KeyType key) {
            this.key$value = key;
            this.key$set = true;
            return self();
        }

        /**
         * @return {@code this}.
         */

        public B required(final boolean required) {
            this.required$value = required;
            this.required$set = true;
            return self();
        }

        @Override

        public String toString() {
            return "AbstractToColumnMapping.AbstractToColumnMappingBuilder(destinationName=" + this.destinationName
                    + ", description=" + this.description + ", key$value=" + this.key$value + ", required$value="
                    + this.required$value + ")";
        }
    }

    private static KeyType $default$key() {
        return KeyType.NONE;
    }

    private static boolean $default$required() {
        return false;
    }

    protected AbstractToColumnMapping(final AbstractToColumnMapping.AbstractToColumnMappingBuilder<?, ?> b) {
        this.destinationName = b.destinationName;
        this.description = b.description;
        if (b.key$set) {
            this.key = b.key$value;
        } else {
            this.key = AbstractToColumnMapping.$default$key();
        }
        if (b.required$set) {
            this.required = b.required$value;
        } else {
            this.required = AbstractToColumnMapping.$default$required();
        }
    }

    public String getDestinationName() {
        return this.destinationName;
    }

    public String getDescription() {
        return this.description;
    }

    public KeyType getKey() {
        return this.key;
    }

    public boolean isRequired() {
        return this.required;
    }

    @Override
    public boolean equals(final Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof AbstractToColumnMapping)) {
            return false;
        }
        final AbstractToColumnMapping other = (AbstractToColumnMapping) o;
        if (!other.canEqual(this)) {
            return false;
        }
        if (this.isRequired() != other.isRequired()) {
            return false;
        }
        final Object this$destinationName = this.getDestinationName();
        final Object other$destinationName = other.getDestinationName();
        if (this$destinationName == null ? other$destinationName != null
                : !this$destinationName.equals(other$destinationName)) {
            return false;
        }
        final Object this$description = this.getDescription();
        final Object other$description = other.getDescription();
        if (this$description == null ? other$description != null : !this$description.equals(other$description)) {
            return false;
        }
        final Object this$key = this.getKey();
        final Object other$key = other.getKey();
        if (this$key == null ? other$key != null : !this$key.equals(other$key)) {
            return false;
        }
        return true;
    }

    protected boolean canEqual(final Object other) {
        return other instanceof AbstractToColumnMapping;
    }

    @Override
    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        result = (result * PRIME) + (this.isRequired() ? 79 : 97);
        final Object $destinationName = this.getDestinationName();
        result = (result * PRIME) + ($destinationName == null ? 43 : $destinationName.hashCode());
        final Object $description = this.getDescription();
        result = (result * PRIME) + ($description == null ? 43 : $description.hashCode());
        final Object $key = this.getKey();
        result = (result * PRIME) + ($key == null ? 43 : $key.hashCode());
        return result;
    }

    @Override

    public String toString() {
        return "AbstractToColumnMapping(destinationName=" + this.getDestinationName() + ", description="
                + this.getDescription() + ", key=" + this.getKey() + ", required=" + this.isRequired() + ")";
    }
}
